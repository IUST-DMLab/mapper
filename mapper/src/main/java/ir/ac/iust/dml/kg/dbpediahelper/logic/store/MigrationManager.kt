package ir.ac.iust.dml.kg.dbpediahelper.logic.store

import ir.ac.iust.dml.kg.access.dao.FkgPropertyMappingDao
import ir.ac.iust.dml.kg.access.dao.FkgTemplateMappingDao
import ir.ac.iust.dml.kg.access.entities.enumerations.MappingStatus
import ir.ac.iust.dml.kg.dbpediahelper.logic.store.entities.ApproveState
import ir.ac.iust.dml.kg.dbpediahelper.logic.store.entities.MapRule
import ir.ac.iust.dml.kg.dbpediahelper.logic.store.entities.ValueType
import ir.ac.iust.dml.kg.raw.utils.LanguageChecker
import org.apache.log4j.Logger
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service

@Service
class MigrationManager {

  val logger = Logger.getLogger(this.javaClass)!!
  @Autowired lateinit var templateDao: FkgTemplateMappingDao
  @Autowired lateinit var propertyDao: FkgPropertyMappingDao
  @Autowired lateinit var holder: MappingHolder

  fun migrate() {
    migrateTemplateMapping()
    migratePropertyMapping()
  }

  val validTemplatePrefixes = mapOf(
      "en" to listOf("infobox ", "taxobox ", "chembox ", "reactionbox ", "ionbox ", "drugbox ", "geobox ",
          "planetbox ", "starbox ", "drugclassbox ", "speciesbox ", "comiccharacterbox "),
      "fa" to listOf("جعبه اطلاعات ", "جعبه ")
  )

  private fun getValidTemplateName(templateName: String): String {
    var valid = false
    val prefixes = validTemplatePrefixes[LanguageChecker.detectLanguage(templateName)]!!
    prefixes.forEach {
      if (templateName.startsWith(it)) {
        valid = true; return@forEach
      }
    }
    if (!valid) {
      prefixes.forEach { prefix ->
        if (holder.isValidTemplate(prefix + templateName)) {
          val result = prefix + templateName
          logger.info("$templateName converted to $result")
          return result
        }
      }
      val result = prefixes[0] + templateName
      logger.info("$templateName converted to new $result")
      return prefixes[0] + templateName
    }
    return templateName
  }

  private fun migratePropertyMapping() {
    var start = System.currentTimeMillis()
    val all = propertyDao.search(page = 0, pageSize = 0, language = null).data
    logger.info("all property data loaded from database " + (System.currentTimeMillis() - start))

    start = System.currentTimeMillis()
    all.forEach {
      val templateName = getValidTemplateName(it.templateName!!.toLowerCase().replace('_', ' ').replace('-', ' '))
      val tm = holder.getTemplateMapping(templateName)
      if (tm.rules!!.isEmpty() && it.ontologyClass == null) return@forEach
      if (tm.rules!!.isEmpty()) {
        logger.info("no explicit template mapping existed for ${it.templateName} to ${it.ontologyClass}")
        tm.rules!!.add(MapRule(
            predicate = "rdf:type",
            constant = "fkgo:" + it.ontologyClass,
            type = ValueType.Resource,
            state = if (it.approved ?: false) ApproveState.Mapped else ApproveState.AutoGenerated
        ))
      }
      val templateProperty = it.templateProperty!!
      val pm = holder.getPropertyMapping(templateName, templateProperty)
      pm.property = templateProperty
      pm.weight = it.tupleCount?.toDouble()
      pm.rules.add(MapRule(
          predicate = it.ontologyProperty!!.replace("dbo:", "fkgo:").replace("dbp:", "fkgp:"),
          type = ValueType.String,
          unit = null,
          constant = null,
          transform = null,
          state = if (it.approved ?: false) ApproveState.Mapped else {
            when (it.status ?: MappingStatus.NearlyMapped) {
              MappingStatus.Mapped -> ApproveState.Mapped
              MappingStatus.NearlyMapped -> ApproveState.Guess
              MappingStatus.Translated -> ApproveState.Guess
              MappingStatus.Multiple -> ApproveState.MultipleGuesses
              MappingStatus.NotMapped -> ApproveState.AutoGenerated
              MappingStatus.AutoGenerated -> ApproveState.AutoGenerated
            }
          }
      ))
    }
    logger.info("all property data written in memory with new structure: " + (System.currentTimeMillis() - start))
  }

  fun migrateTemplateMapping() {
    var start = System.currentTimeMillis()
    val all = templateDao.search(page = 0, pageSize = 0).data
    logger.info("all template data loaded from database " + (System.currentTimeMillis() - start))

    start = System.currentTimeMillis()
    all.forEach {
      val templateName = it.templateName!!.toLowerCase().replace('_', ' ').replace('-', ' ')
      val tm = holder.getTemplateMapping(templateName)
      tm.rules!!.add(MapRule(
          predicate = "rdf:type",
          constant = "fkgo:" + it.ontologyClass,
          type = ValueType.Resource,
          state = if (it.approved ?: false) ApproveState.Mapped else ApproveState.AutoGenerated
      ))
      tm.weight = it.tupleCount!!.toDouble()
      tm.creationEpoch = it.updateEpoch
      tm.modificationEpoch = it.updateEpoch
    }

    logger.info("all template data written in memory with new structure: " + (System.currentTimeMillis() - start))
  }
}